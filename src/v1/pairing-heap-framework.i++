/*
  Implementation of the pairing-heap framework.
*/

#include <algorithm> // std::swap
#include "assert.h++"
#include <climits> // LONG_MAX
#include <iostream>
#include <list>
#include <vector>
#include <utility> // std::pair

namespace cphstl {

  template <typename V, typename P, typename C, typename A,
            typename E>
  pairing_heap_framework<V, P, C, A, E>::
  pairing_heap_framework(C const& c, A const& a)
    : comparator_(c), allocator_(a), top_(0), size_(0) {
    policy_ = P(c, a);
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  pairing_heap_framework<V, P, C, A, E>::
  pairing_heap_framework()
    : top_(0), size_(0) {
    comparator_ = C();
    allocator_  = A();
    policy_ = P(comparator_, allocator_);
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  pairing_heap_framework<V, P, C, A, E>::~pairing_heap_framework() {
    // Precondition: The data structure contains no elements.
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  E* pairing_heap_framework<V, P, C, A, E>::begin() const {
    return policy_.begin();
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  E* pairing_heap_framework<V, P, C, A, E>::end() const {
    return policy_.end();
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  A pairing_heap_framework<V, P, C, A, E>::get_allocator() const {
    return allocator_;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  C pairing_heap_framework<V, P, C, A, E>::get_comparator() const {
    return comparator_;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  typename pairing_heap_framework<V, P, C, A, E>::size_type pairing_heap_framework<V, P, C, A, E>::size() const {
    return size_;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  typename pairing_heap_framework<V, P, C, A, E>::size_type pairing_heap_framework<V, P, C, A, E>::max_size() const {
    return 0;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  E* pairing_heap_framework<V, P, C, A, E>::top() const {
    return min_;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  void pairing_heap_framework<V, P, C, A, E>::insert(E* p) {
    assert(p != NULL);
    // heap is empty
    if(top_ == NULL) {
      min_ = top_ = p;
      size_ = 1;
    } else {
      policy_.insert(&top_, &min_, p);
      size_ += 1;
    }
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  void
  pairing_heap_framework<V, P, C, A, E>::increase(E* p, V const& v) {
    assert(p != NULL);
    assert(comparator_(p->element(), v));
    policy_.increase(&top_, &min_, p, v);
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  E*
  pairing_heap_framework<V, P, C, A, E>::extract() {
    if(size_ == 0) {
      return NULL;
    } else if (size_ == 1 && top_ != NULL) {
      size_ = 0;
      E* elem = top_;
      min_ = top_ = NULL;
      return elem;
    }
    E* elem = policy_.extract(&top_, &min_);
    size_ -= 1;
    return elem;
  }


  template <typename V, typename P, typename C, typename A,
            typename E>
  void
  pairing_heap_framework<V, P, C, A, E>::extract(E* p) {
    if(p == min_) {
      extract();
      return;
    }
    policy_.extract(&top_, &min_, p);
    //is_valid();
    size_ -= 1;
  }


  template <typename V, typename P, typename C, typename A,
            typename E>
  int
  pairing_heap_framework<V, P, C, A, E>::is_valid_tree(E* root) {
    E* prev = root;
    E* node = root->child_;

    int count = 0;
    while(node != NULL) {
      assert(node->left_ != NULL);
      assert(node->left_ == prev);
      count += 1 + is_valid_tree(node);

      prev = node;
      node = node->right_;
    }
    return count;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  void
  pairing_heap_framework<V, P, C, A, E>::is_valid() {
    if(size_ == 0)
      return;

    assert(top_ != NULL);
    assert(top_->left_ == NULL && top_->right_ == NULL);
    is_valid_tree(top_);

  }


  template <typename V, typename P, typename C, typename A,
            typename E>
  void
  pairing_heap_framework<V, P, C, A, E>::meld(pairing_heap_framework& other) {
    policy_.meld(&top_, &min_, other);
    size_ += other.size_;
  }

  template <typename V, typename P, typename C, typename A,
            typename E>
  void
  pairing_heap_framework<V, P, C, A, E>::swap(pairing_heap_framework& other) {
    E*        newtop  = other.top_;
    size_type newsize = other.size_;
    other.top_  = newtop;
    other.size_ = newsize;
    top_  = newtop;
    size_ = newsize;
  }


}


