\documentclass{DIKU-article}[2010/01/13]

\usepackage[utf8]{inputenc}
\usepackage[OT1]{fontenc}
\usepackage[danish]{babel}
\usepackage{t1enc}

%\selectdanish % Add this if your report is in Danish

\usepackage{epsfig} 

%\setlength{\errorcontextlines}{999} %Can be used for debugging purposes
%\alternativecitationstyle
%\draft

\titlehead{Self-adjusting heaps}
\authorhead{Johan Brinch and Asser Schrøder Femø}

\title{Self-adjusting heaps: A performance comparison}

\author{
Johan Brinch
\and
Asser Schrøder Femø
}

\institute{
Department of Computing, University of Copenhagen\\
Universitetsparken 1, DK-2100 Copenhagen East, Denmark\\
\email{...@diku.dk}
\and
\email{asser@diku.dk}
}

\dates{CPH STL Report 2010-?, January 2010.}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\begin{subject}
\end{subject}

\section{Introduction}

The aim of this project is to develop a meldable priority queue framework in
order to implement and compare the following pairing heap variants: The original
pairing heap by Fredman et al, the pairing heap with Stasko-Vitter lazy insertion and
the pairing heap with costless meld by Elmasry. We also include performance
comparisons with existing CPH STL priority queues.

\section{Priority queue variants}

\begin{description}
\item{Original pairing heap} by Fredman et al\cite{fredman} is intended as an
alternative to the Fibonacci heap. While theoretically slower (conjectured just
as fast but not proven) it is much simpler to implement and faster in practice.
All operations run in $O(\lg n)$ amortized time.

\item{Stasky-Vitter lazy insertion} expands on the original pairing heap by
modifying the insert procedure to maintain an auxiliary list, or forest, of
nodes to be inserted into the heap tree which is then merged into the main tree
when a delete-min operation is executed. This modification improves the bound
for insert to $O(1)$ amortized.

\item{Pairing heap with Costless Meld} by Elmasry\cite{costlessmeld} expands on
the lazy insertion method by having decrease-key also use an auxiliary list to
determine whether a nodes key was decreased deferring the clean-up work to a
later time. This makes decrease-key run in $O(\lg \lg n)$ amortized time.
Melding two heaps only cleans up the auxiliary structures of the smaller heap
before pairing the heaps as in the original method, making meld have zero
amortized cost.

\item{Pairing heap with Costless Meld and Lazy Insert} is a combination of the
two abovementioned heaps, with both extensions in use.
\end{description}

\section{Implementation}

We have implemented all three variants into one pairing queue framework. Due to
the small differences between the variants we use a policy template to determine
which variant to use. 

Our framework is based on the code for Priority-queue-framework in CPH STL as it
shares the interface and the same general structure. We considered the
possibility of simply extending or directly using this framework but due to
differences in the internal node structure we decided against that.
Specifically, Priority-queue-framework's \verb!heap_node! structure allows only
parent, left and right pointers where we need a sibling list structure because
pairing heaps use multiway trees.

\subsection{Main framework}

The framework consists mainly of the class \verb!pairing_heap_framework! which
is based on \verb!cphstl::priority_queue_framework!. It implements
some of the \verb!extract! logic that is identical for all our pairing heap
variants. For some cases, and for all other heap operations it defers to the
\emph{policy}, which is given as template parameter \verb!P!.

\subsection{Policies}

- Framework
- Policies
- Integration with stl-meldable-priority-queue as realizator
- Benchmarking tests
- Difficulties with different versions of Priority-queue-framework,
  Meldable-priority-queue and Iterator from CPH STL. Code was updated while the
  project was in progress.
- Memory usage .. three pointers per node?
- Pointer juggling => cause of many errors
- Usage of other CPH STL code .. cphstl::doubly\_linked\_list for example

In the Costless Meld heap, when doing phase 2 of the cleanup we can save a few
comparisons by observing that when combining the $\Theta(\lg n)$ trees in each
group we already know the order in which to link the trees since they have been
sorted according to the root nodes. Our link operation can then just link the
trees without doing the usual comparison between the root nodes. While this is
not an actual saving (we just moved the comparison from the link operation to
the sorting of the trees) it is an important implementation detail easily
overlooked.

Working with and understanding CPH STL proved somewhat difficult and while we
were able to quickly make an implementation of the pairing heaps, it took a
while to integrate everything and weed out the bugs. Our lacking experience with
C++ and templating in particular probably didn't help.

\section{Performance}

In order to run the code you need 2010 versions of Iterator and
Meldable-priority-queue from CPH STL (anything after 2010-01-01 should be fine),
but pre-2010 Priority-queue-framework files.

Additionally we had to fix a bug in Iterator/Code/priority-queue-iterator.h++
line 77; change template parameter to F (or something else that isn't used
elsewhere in the file) since E was already declared .

- Sorting of the auxiliary forest in costless meld takes a long time. Could we
  optimize that somehow?

\begin{acknowledgements}
This section comes before the References and is unnumbered.
\LaTeX-en\-viron\-ment is \verb|acknowledgements|.
\end{acknowledgements}

\bibliographystyle{DIKU} % Use DIKU-alternative for the other citation style
\bibliography{report}

\end{document}

